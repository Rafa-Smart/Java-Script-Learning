<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>latihan</title>
</head>
<body>
    <script>
        // rekursif adalah fungsi yang memanggil dirinya sendiri

        // dan perhatikan ketika menggnakan rekursif ini harus berakhir dan menghasilkan sebuah nilai,
        
        // bedanya dengan higher order function itu karena kalo hof itu menjadi kan fungsi lain sebegai parameter atau pun sebuah return, namun jika rekursif itu mereturn dirinya sendiri bukan fungsi lain

        // // misal
        // function rekursif(n) {
        //     return rekursif()
        // }
        // rekursif()

        // conth lagi
        // ini akan memanggil 10 sampai 1
        // for(i = 10; i >= 1; i--){
        //     console.log(i)
        // }

        // kita juga bisa pake rekursif
        // function rekursif(n) {
        //     console.log(n)
        //     return rekursif(n-1)
        // }
        // // rekursif(10)

        // makanya kita harus pake base case
        function rekursif(n){
            if (n === 0){
                return // yang maksudna adalah break atau sudah dikembalikan yang artinya fungsinya sudah berhenti, karena jika program sudah sampe ke return maka fungsinya akan berhenti
            }
            console.log(n)
            return rekursif(n-1)
        }
        rekursif(5)

        console.log("========")

        // jadi ini bisa di buat faktorial
        // jadi faktorial itu gini 5! = 5x4x3x2x1
        function Faktorial(n){
            if (n === 0){
                return true // maka langsung di kali kan yang bawahnya
                // karena jika true maka akan dijalankan semua program dibawahnya yaitu return n * faktorial(n-1), dan jika diisi false maka tidak akan menjalaskan program dibawahnya dan akan langsung berhenti, yan ghasilnya akan 0 karena ifnya adalah jika n === 0 maka return false yang artinya selesai,

                // tapi sebenarnya itu return true itu mengembalikan nilai 1 yang artina fungsi rekursif nya akan berhenti
            }
            return n * Faktorial(n-1)
        }
        // jadi cara kerjany itu gini
        /* 
        misal user ngasih Faktorial(5) maka;
        5 * faktorial(5-1) = 5 * faktorial(4)
        5 * (4 * faktorial(4-1)) = faktorial(3)
        5 * 4 * (3 * faktorial(3-1))) = faktorial(2)
        5 * 4 * (3 * (2 * faktorial(2-1)))) = faktorial(1)
        seteelah itu baru masuk ke yg if maka akan di return niali 1 atau true karena kita akan menjalan kan return yang kedua caranya adalah dnegan men true kan return yang pertama agar menjalankan return yang kedua, maka;
        // baru di oeprasikan
        5 * 4 * (3 * (2 * 1)) = 120

          */
        console.log(Faktorial(5))
        
        console.log("=============")
        hasil = 1
        for(i = 5;i>=1;i--){
            hasil *= i
        }
        console.log(hasil)
        /* penjelasan 
            1 (inisialisasi)
            1 × 5 = 5
            5 × 4 = 20
            20 × 3 = 60
            60 × 2 = 120
            120 × 1 = 120 
        */

        // semua looping bisa dibuat rekursif tetapi tiak semua rekursif bisa dibuat looping

        function lagij(n){
            if(n === 11){
                return
            }
            console.log(n)
            return lagij(n+1)
        }
        lagij(1)

        function tesRekursif(n){
            if(n === 20){
                return
            }
            console.log(n)
            return tesRekursif(n+1)
        }

        function tes(n){
            let hasil;
            return function (n){
                if(n === 0){
                    return true
                }
                hasil += tes(n-1)
                return tes(n-1)
            }
            return hasil
        }

        function es(n1){
            console.log("ini coba lagi, liat dah")
            let hasil =0;
            if(n1 === 0){
                return
            }
            return hasil += es(n1-1)
        }



        console.log(es(10))
        console.log("tes")
        console.log(tes(10))
        let t = tes(10)
        console.log(t)


        console.log("tesss aja ")
        function tambahLagi(n){
            if(n === 0){
                return 1
            }
            return n + tambahLagi(n-1)
        }

        console.log(tambahLagi(10))




        // ini cara saya lagi yang paling terbaru
        // dan ini berhaisl
        console.log("tes rekursif")
        function teslagi(n){
            let hasil = 0;
            if(n===0){
                return hasil
            }
            return hasil += n + teslagi(n-1);
        }
        console.log(teslagi(10))
    </script>
</body>
</html>
<!-- PENTING -->
 <!-- Ketika n sama dengan 0, fungsi Faktorial Anda mengembalikan 1.
Ketika n lebih besar dari 0, fungsi Faktorial Anda mengembalikan hasil dari n dikalikan dengan hasil dari Faktorial(n-1).
Jadi, ketika Anda memanggil Faktorial(5), misalnya, fungsi akan bekerja sebagai berikut:

Faktorial(5) mengembalikan 5 * Faktorial(4)
Faktorial(4) mengembalikan 4 * Faktorial(3)
Faktorial(3) mengembalikan 3 * Faktorial(2)
Faktorial(2) mengembalikan 2 * Faktorial(1)
Faktorial(1) mengembalikan 1 * Faktorial(0)
Faktorial(0) mengembalikan 1
Jadi, hasil akhirnya adalah 5 * 4 * 3 * 2 * 1 * 1 = 120.

Sekarang, tentang pertanyaan Anda tentang mengapa n tidak terus di kurangi menjadi 0 ketika n sama dengan 0. Jawabannya adalah karena fungsi Faktorial Anda menggunakan teknik yang disebut "rekursi" untuk menghitung faktorial. Dalam rekursi, fungsi memanggil dirinya sendiri dengan nilai yang lebih kecil sampai mencapai nilai dasar (dalam hal ini, n sama dengan 0).

Ketika n sama dengan 0, fungsi Faktorial Anda tidak memanggil dirinya sendiri lagi, tetapi sebenarnya mengembalikan nilai dasar 1. Jadi, tidak ada lagi pengurangan n menjadi 0 karena fungsi sudah mencapai nilai dasar.

Namun, perlu diingat bahwa kode Anda memiliki kesalahan, karena tidak ada kondisi untuk menghentikan rekursi ketika n kurang dari 0. Jika Anda memanggil Faktorial(-1), misalnya, fungsi akan terus memanggil dirinya sendiri dengan nilai yang lebih kecil sampai mencapai batas maksimum rekursi, yang dapat menyebabkan kesalahan. -->